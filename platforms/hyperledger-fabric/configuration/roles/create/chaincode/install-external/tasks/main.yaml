###########################################################################################

# This task copies the certificates used for the packaging to temp folder
- name: Copies the certificate to temp folder
  shell: |
    # Creates temp folder for packaging
    mkdir -p tmp/package/{{ org_ns }}

    # Copies certificates from ca-tools pod to temp folder
    export CA_TOOL_CLI=$(KUBECONFIG={{ kubernetes.config_file }} kubectl get po -n {{ org_ns }} | grep "ca-tools" | awk '{print $1}');
    KUBECONFIG={{ kubernetes.config_file }} kubectl cp {{ org_ns }}/${CA_TOOL_CLI}:crypto-config/peerOrganizations/{{ org_ns }}/users/{{ first_peer_name }}-chaincode@{{ org_ns }}/tls ./tmp/package/{{ org_ns }};
  vars:
    chaincode_name: "{{ peers[0].chaincode.name | lower }}"
    chaincode_version: "{{ peers[0].chaincode.version }}"
    chaincode_tls_disabled: "{{ peers[0].chaincode.tls_disabled }}"
    package_name: "{{ peers[0].chaincode.name | lower }}_{{ peers[0].chaincode.version }}"
    first_peer_name: "{{ peers[0].name }}"
  when:
    - peers is defined
    - peers | length > 0

# This task packs the external chaincode details
- name: Generation chaincode connection details with mTLS
  shell: |
    cd tmp/package/{{ org_ns }}
    echo '{}' | jq --arg cc_addr "chaincode-{{ chaincode_name }}-{{ chaincode_version }}-{{ org_name }}.{{ org_ns }}.svc.cluster.local:7052" \
      --arg c_key "$(cat ./client.key)" \
      --arg c_crt "$(cat ./client.crt)" \
      --arg ca_crt "$(cat ./ca.crt)" \
      '{"address": $cc_addr, "dial_timeout":"10s", "tls_required":true, "client_auth_required":true, "client_key":$c_key, "client_cert":$c_crt, "root_cert":$ca_crt}' > connection.json
    echo '{"path":"","type":"external","label":"'{{ package_name }}'"}' > metadata.json;
  vars:
    chaincode_name: "{{ peers[0].chaincode.name | lower }}"
    chaincode_version: "{{ peers[0].chaincode.version }}"
    package_name: "{{ peers[0].chaincode.name | lower }}_{{ peers[0].chaincode.version }}"
  when:
    - peers is defined
    - peers | length > 0
    - peers[0].chaincode.tls_disabled == false

# This task packs the external chaincode details without tls
- name: Generation chaincode connection details without TLS
  shell: |
    CHAINCODE_ADDR=chaincode-{{ chaincode_name }}-{{ chaincode_version }}-{{ org_name }}.{{ org_ns }}.svc.cluster.local:7052
    cd tmp/package/{{ org_ns }}
    echo '{"address":"'${CHAINCODE_ADDR}'","dial_timeout":"10s","tls_required":false,"client_auth_required":false,"client_key":"","client_cert":"","root_cert":""}' > connection.json
    echo '{"path":"","type":"external","label":"'{{ package_name }}'"}' > metadata.json
  vars:
    chaincode_name: "{{ peers[0].chaincode.name | lower }}"
    chaincode_version: "{{ peers[0].chaincode.version }}"
    package_name: "{{ peers[0].chaincode.name | lower }}_{{ peers[0].chaincode.version }}"
  when:
    - peers is defined
    - peers | length > 0
    - peers[0].chaincode.tls_disabled == true

# This tasks packs the chaincode details file
- name : Packs the chaicode package file
  shell: | 
    # Packages chaincode details
    cd tmp/package/{{ org_ns }}
    tar cfz code.tar.gz connection.json;
    tar cfz {{ package_name }}.tgz code.tar.gz metadata.json;
  vars:
    package_name: "{{ peers[0].chaincode.name | lower }}_{{ peers[0].chaincode.version }}"
  when:
    - peers is defined
    - peers | length > 0

# This task checks the 
- name: Checks the status of the package file
  stat:
    path: tmp/package/{{ org_ns }}/{{ package_name }}.tgz
  register: packagefile
  vars:
    package_name: "{{ peers[0].chaincode.name | lower }}_{{ peers[0].chaincode.version }}"

# This task stops the playbook if the package details file exists
- name: Fails if the package file doesn't exist
  fail:
    msg: Package doesn't exist, please check the process
  when: packagefile.stat.exists == false

# This task saves the package details to vault in base64 format
- name: Saves the package file to vault in base64 format
  shell: |
    PACKAGE_VAULT_ADDR={{ vault.secret_path | default('secret') }}/crypto/peerOrganizations/{{ org_ns }}/chaincode/{{ chaincode_name }}/package/v{{ chaincode_version }}
    vault write ${PACKAGE_VAULT_ADDR} package-base64="$(cat ./tmp/package/{{ org_ns }}/{{ package_name }}.tgz | base64)"
  vars:
    chaincode_name: "{{ peers[0].chaincode.name | lower }}"
    chaincode_version: "{{ peers[0].chaincode.version }}"
    package_name: "{{ peers[0].chaincode.name | lower }}_{{ peers[0].chaincode.version }}"
  environment:
    VAULT_ADDR: "{{ vault.url }}"
    VAULT_TOKEN: "{{ vault.root_token }}"

# This task installs the external chaincode details
- name: Installs the external chaincode details
  include_tasks: nested_main.yaml
  vars:
    chaincode_name: "{{ peer.chaincode.name | lower }}"
    chaincode_version: "{{ peer.chaincode.version }}"
    envspace: "{{ envspace }}"
  loop: "{{ peers }}"
  loop_control:
    loop_var: peer
  when: 
    - peer.chaincode is defined
    - peer.chaincode.external_chaincode is defined
    - peer.chaincode.external_chaincode == true  
